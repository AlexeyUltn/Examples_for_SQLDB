Ниже представлен код для RFM-классификации пользователей приложения.

--Создание таблиц 

CREATE TABLE analysis.dm_rfm_segments ( 

  user_id INT NOT NULL PRIMARY KEY, 

  recency INT NOT NULL CHECK(recency >= 1 AND recency <= 5), 

  frequency INT NOT NULL CHECK(frequency >= 1 AND frequency <= 5), 

  monetary_value INT NOT NULL CHECK(monetary_value >= 1 AND monetary_value <= 5) 

); 

 

CREATE TABLE analysis.tmp_rfm_recency ( 

 user_id INT NOT NULL PRIMARY KEY, 

 recency INT NOT NULL CHECK(recency >= 1 AND recency <= 5) 

); 

CREATE TABLE analysis.tmp_rfm_frequency ( 

 user_id INT NOT NULL PRIMARY KEY, 

 frequency INT NOT NULL CHECK(frequency >= 1 AND frequency <= 5) 

); 

CREATE TABLE analysis.tmp_rfm_monetary_value ( 

 user_id INT NOT NULL PRIMARY KEY, 

 monetary_value INT NOT NULL CHECK(monetary_value >= 1 AND monetary_value <= 5) 

); 


--Создание 5 вьюх таблиц из базы production 

create or replace view ordertimes as 

select * from production.orderitems; 

 

create or replace view orders as 

select * from production.orders; 

 

create or replace view orderstatuses as 

select * from production.orderstatuses; 

 

create or replace view orderstatuslog as 

select * from production.orderstatuslog; 

 

create or replace view products as 

select * from production.products; 

--Создание вьюхи orders_new 

create or replace view analysis.orders_new as 

select o.order_id, o.order_ts, o.user_id, o.bonus_payment, o.payment, o."cost", o.bonus_grant, s.key status 

/*Вьюха создается сразу тс ключом в формате varchar*/ 

from orders o 

	 join OrderStatuses s on o.status=s.id 

where date_part('year', order_ts)=2022


--Создание вьюхи для отображения id клиентов у оторых нет заказов с типом Closed 

create or replace view dist_st as 

select y.user_id, o.status 

from (select user_id, count(*) cnt 

	  from (select distinct user_id, status 

			from analysis.orders_new) t 

	  group by user_id 

	  having count(status)=1)y 

 	join (select distinct user_id, status 

		  from analysis.orders_new) o on y.user_id=o.user_id 

where status='Cancelled' 


--Наполнение recency 

insert into analysis.tmp_rfm_recency 

with order_ts_total as 

  (select user_id, 

		  max(order_ts) order_ts 

   from analysis.orders_new 

   where status='Closed' 

   group by user_id 

   union all 

   select user_id, (select min(order_ts) from analysis.orders_new) order_ts 

   from dist_st 

  ), 

all_cnt as 

  (select 

	  count(distinct user_id) cnt 

  from order_ts_total), 

user_rn as 

  (select 

  		user_id, 

  		row_number() over (order by order_ts) rn 

  from order_ts_total) 

select 

	i.user_id, 

	case when cnt/cast(5 as float)>=rn then 1 

		 when cnt/cast(5 as float)*2>=rn then 2 

		 when cnt/cast(5 as float)*3>=rn then 3 

		 when cnt/cast(5 as float)*4>=rn then 4 

		 else 5 end Recency 

from order_ts_total i 

	  join all_cnt c on 1=1 

	  join user_rn r on i.user_id=r.user_id 

order by rn; 

 

--Наполнение frequency 

insert into analysis.tmp_rfm_frequency 

with order_total as 

	(select 

		  user_id, 

		  count(distinct order_id) order_id 

	from analysis.orders_new 

	where status='Closed' 

	group by user_id 

	union all 

    select 

	 	user_id, 

	 	0 order_ts 

    from dist_st), 

all_cnt as 

	(select 

		count(distinct user_id) cnt 

	 from order_total), 

user_rn as 

	(select 

		user_id, 

		row_number() over (order by order_id) rn 

	from order_total) 

select 

	  i.user_id, 

	  case when cnt/cast(5 as float)>=rn then 1 

		   when cnt/cast(5 as float)*2>=rn then 2 

		   when cnt/cast(5 as float)*3>=rn then 3 

		   when cnt/cast(5 as float)*4>=rn then 4 

		   else 5 end Frequency 

from order_total i 

	 join all_cnt c on 1=1 

	 join user_rn r on i.user_id=r.user_id 

order by rn; 

 

--Наполнение monetary_value 

insert into analysis.tmp_rfm_monetary_value 

with id_total as 

	(select 

		user_id, 

		sum(payment) payment 

	from analysis.orders_new 

	where status='Closed' 

	group by user_id 

	union all 

    select 

	 	user_id, 

	 	0 order_ts 

    from dist_st), 

all_cnt as 

	 (select 

		count(distinct user_id) cnt 

	 from id_total), 

user_rn as 

	(select 

		user_id, 

		row_number() over (order by payment) rn 

	from id_total) 

select 

	i.user_id, 

	case when cnt/cast(5 as float)>=rn then 1 

		 when cnt/cast(5 as float)*2>=rn then 2 

		 when cnt/cast(5 as float)*3>=rn then 3 

		 when cnt/cast(5 as float)*4>=rn then 4 

		 else 5 end MonetaryValue 

from id_total i 

	 join all_cnt c on 1=1 

	 join user_rn r on i.user_id=r.user_id 

order by rn; 

 

--Наполнение dm_rfm_segments 

insert into analysis.dm_rfm_segments 

select r.user_id, Recency, Frequency, Monetary_Value 

	  from analysis.tmp_rfm_recency r 

	  join analysis.tmp_rfm_frequency f on r.user_id=f.user_id 

	  join analysis.tmp_rfm_monetary_value m on r.user_id=m.user_id;

--ТОП 10 

select * 

from analysis.dm_rfm_segments 

order by user_id 

limit 10 


--Перезапись вьюхи orders_new, при условии отсутствия статуса в исходной таблице 

create or replace view analysis.orders_new as 

with OrderStatusLog as 

	(select 

		order_id, 

		status_id, 

		dttm, 

		row_number() over (partition by order_id order by dttm desc) rn 

	from orderStatusLog) 

select  o.order_id, o.order_ts, o.user_id, o.bonus_payment, o.payment, o."cost", o.bonus_grant, ss.key status 

/*Перезапись вьюхи с ключом в формате varchar 

  Поэтому все будет работать корректно*/ 

from orders o 

	 join OrderStatusLog s on o.order_id=s.order_id 

	 join production.OrderStatuses ss on s.status_id=ss.id 

where s.rn=1
